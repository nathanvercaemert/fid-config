* system setting
** utf8 default
#+BEGIN_SRC emacs-lisp
  (set-charset-priority 'unicode)
  (prefer-coding-system 'utf-8-unix)
  (set-default-coding-systems 'utf-8)
#+END_SRC
** utilities
*** don't prompt on kill process
#+BEGIN_SRC emacs-lisp
  (defun set-no-process-query-on-exit ()
    (let ((proc (get-buffer-process (current-buffer))))
      (when (processp proc)
        (set-process-query-on-exit-flag proc nil))))
#+END_SRC
*** merge plist
#+BEGIN_SRC emacs-lisp
  (defun plist-merge (&rest plists)
    (if plists
        (let ((result (copy-sequence (car plists))))
          (while (setq plists (cdr plists))
            (let ((plist (car plists)))
              (while plist
                (setq result (plist-put result (car plist) (car (cdr plist)))
                      plist (cdr (cdr plist))))))
          result)
      nil))
#+END_SRC
*** remove-nth
#+BEGIN_SRC emacs-lisp
  (defun remove-nth (n list)
    (declare
     (type (integer 0) n)
     (type list list))
    (if (or (zerop n) (null list))
        (cdr list)
      (cons (car list) (remove-nth (1- n) (cdr list)))))
#+END_SRC

** prompts
*** yes or no -> y or p
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** kill processes without confirmation
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-processes nil)
#+END_SRC
** keyboard
*** unbind insert key
this avoids accidentally entering overwrite mode
#+BEGIN_SRC emacs-lisp
  (define-key global-map [(insert)] nil)
  (define-key global-map [(insertchar)] nil)
#+END_SRC
* package management
** MELPA marmalade(not currently) my packages
slows down startup. obviously need this to install things
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (setq package-archives '(("melpa" . "http://melpa.org/packages/")
			 ("gnu" . "http://elpa.gnu.org/packages/")))
  ;; (add-to-list 'package-archives
  ;;              '("marmalade" . "http://marmalade-repo.org/packages/") t)
  ;; Comment/uncomment this line to enable MELPA Stable if desired.  See `package-archive-priorities`
  ;; and `package-pinned-packages`. Most users will not need or want to do this.
  ;; (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
  (package-initialize)

  (package-refresh-contents)

  ;; install packages

  ;; myPackages contains a list of package names
  (defvar myPackages
    '(
      zenburn-theme
      expand-region
      multiple-cursors
      ahk-mode
      yasnippet
      use-package
      auctex-latexmk
      ivy-rich
      counsel
      bind-key
      hydra
      company
      phi-search
      interaction-log
      drag-stuff
      )
    )

  ;; Scans the list in myPackages
  ;; If the package listed is not already installed, install it
  (mapc #'(lambda (package)
	    (unless (package-installed-p package)
	      (package-install package)))
	myPackages)
#+END_SRC

#+RESULTS:
| elpy | flycheck | blacken | ein | pdf-tools | jupyter | exec-path-from-shell | zenburn-theme | expand-region | multiple-cursors | ahk-mode | yasnippet | use-package | auctex-latexmk | ivy-rich | counsel | plantuml-mode | quelpa | bind-key | lsp-mode | lsp-ui | ccls | lsp-treemacs | helm-lsp | hydra | company | helm-xref | dap-mode | org-roam | deft | phi-search | interaction-log | diredful | rg | org-noter | ivy-bibtex | org-ref | org-roam-bibtex | helm-bibtex | hide-mode-line | lsp-java | treemacs | lsp-ui | imenu | xref | drag-stuff |

*** refresh package list
#+BEGIN_SRC emacs-lisp
(package-refresh-contents)
#+END_SRC
** quelpa
don't currently use any quelpa packages
;#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'quelpa)
    (with-temp-buffer
      (url-insert-file-contents "https://raw.githubusercontent.com/quelpa/quelpa/master/quelpa.el")
      (eval-buffer)
      (quelpa-self-upgrade)))
  (use-package quelpa)
#+END_SRC
** import use-package
#+BEGIN_SRC emacs-lisp
  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC
** straight.el
#+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC
** my packages straight.el
have to install via straight.el
;#+BEGIN_SRC emacs-lisp
  (straight-use-package 'good-scroll)
  (straight-use-package
   '(notdeft
     :type git :host github :repo "hasu/notdeft"
     :files ("*.el" "xapian")))
#+END_SRC
** require bindkey
#+BEGIN_SRC emacs-lisp
(require 'bind-key)
#+END_SRC
* appearances
** diminish
#+BEGIN_SRC emacs-lisp
  (use-package diminish      :demand t)
#+END_SRC
** window (frame) initialization

*** only show errors (not warnings) on startup
#+BEGIN_SRC emacs-lisp
(setq warning-minimum-level :emergency)
#+END_SRC
*** hide the toolbar
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC

*** hide the menubar
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
#+END_SRC

*** hide the scrollbar
#+BEGIN_SRC emacs-lisp
  (toggle-scroll-bar -1)
#+END_SRC

**** hide the scrollbar on creating a new frame
#+BEGIN_SRC emacs-lisp
  (defun my-disable-scroll-bars (frame)
    (modify-frame-parameters frame
                             '((vertical-scroll-bars . nil)
                               (horizontal-scroll-bars . nil))))
  (add-hook 'after-make-frame-functions 'my-disable-scroll-bars)
#+END_SRC

*** hide the title bar
#+BEGIN_SRC emacs-lisp
  (setq default-frame-alist '((undecorated . t)))
#+END_SRC
** font
#+BEGIN_SRC emacs-lisp
  (setq text-scale-mode-step 1.08)
  (set-face-attribute 'default nil :height 160)
#+END_SRC

#+RESULTS:
*** font note
Iosevka is a pleasant font that is popular for coding
** theme (zenburn
#+BEGIN_SRC emacs-lisp
  (setq zenburn-override-colors-alist
        '(("zenburn-bg" . "#000000")
          ("zenburn-bg-2"  . "#102020")
          ("zenburn-bg-1"  . "#202020")
          ("zenburn-bg-08"  . "#252525")
          ("zenburn-bg-05"  . "#342828")
          ("zenburn-bg+05"  . "#2D2D2D")
          ("zenburn-bg+1"  . "#303030")
          ("zenburn-bg+2"  . "#323232")
          ("zenburn-bg+3"  . "#353535")
        ;; '(("zenburn-bg" . "#000000")
        ;;   ("zenburn-bg-2"  . "#202020")
        ;;   ("zenburn-bg-1"  . "#232323") hightlight
        ;;   ("zenburn-bg-08"  . "#252525")
        ;;   ("zenburn-bg-05"  . "#282828") hl-line
        ;;   ("zenburn-bg+05"  . "#2D2D2D")
        ;;   ("zenburn-bg+1"  . "#303030")
        ;;   ("zenburn-bg+2"  . "#323232")
        ;;   ("zenburn-bg+3"  . "#353535")
          ("zenburn-fg-1"     . "#555555")
          ("zenburn-fg-05"    . "#888888")
          ;; this is a trainwreck
          ;; ("zenburn-fg"       . "#989890")
          ;; ("zenburn-fg"       . "#999999")
          ("zenburn-fg"     . "#DDDDDD")
          ("zenburn-fg+1"     . "#EEEEEE")
          ("zenburn-fg+2"     . "#FFFFFF")))
  (load-theme 'zenburn t)
  (set-face-background 'mode-line-inactive "#202020")
  (set-face-background 'mode-line "#2D2D2D")
#+END_SRC
** modeline
mostly so that I can enable pixel scrolling, but it also looks nice
- pixel scrolling has issues when the modeline updates too much, and this one is efficient
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :demand
    :config
    (doom-modeline-mode 1)
    ;; Whether display icons in the mode-line.
    ;; While using the server mode in GUI, should set the value explicitly.
    (setq doom-modeline-icon nil)
    ;; How tall the mode-line should be. It's only respected in GUI.
    ;; If the actual char height is larger, it respects the actual height.
    (setq doom-modeline-height 1)
    )
#+END_SRC
*** show column number in mode line
#+BEGIN_SRC emacs-lisp
(column-number-mode)
#+END_SRC
** rainbow delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook ((prog-mode . rainbow-delimiters-mode)))
#+END_SRC
** no scratch buffer description
#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil)
#+END_SRC
** recursive minibuffers
;#+BEGIN_SRC emacs-lisp
(setq enable-recursive-minibuffers t)
(minibuffer-depth-indicate-mode)
#+END_SRC
** toggle linum mode
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f5> d" 'linum-mode)
#+END_SRC
** toggle truncate lines
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f5> e" 'toggle-truncate-lines)
#+END_SRC
** highlight error messages more aggresively
#+BEGIN_SRC emacs-lisp
(setq next-error-message-highlight t)
#+END_SRC
** highlight current line (hl-line-mode)
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'hl-line-mode)
  (add-hook 'text-mode-hook #'hl-line-mode)
  (add-hook 'dired-after-readin-hook #'hl-line-mode)
  
#+END_SRC
** beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :diminish
    :config
    (beacon-mode 1)
    )
#+END_SRC
** all the icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :if (display-graphic-p))
#+END_SRC
** indent highlight indication
#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
    :defer
    :init
    (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
    (setq highlight-indent-guides-method 'column)
    (setq highlight-indent-guides-responsive 'top)
    (setq highlight-indent-guides-auto-enabled nil)
    (setq highlight-indent-guides-delay 0.1)
    :config
    (set-face-background 'highlight-indent-guides-odd-face "#102020")
    (set-face-background 'highlight-indent-guides-top-odd-face "#342828")
    (set-face-background 'highlight-indent-guides-even-face "#102020")
    (set-face-background 'highlight-indent-guides-top-even-face "#342828")
    )
#+END_SRC
** ivy-posframe
#+BEGIN_SRC emacs-lisp
  (use-package ivy-posframe
    :after ivy
    :demand t
    :config
    (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
    (ivy-posframe-mode 1)
    )
#+END_SRC
** visual line mode (word wrapping)
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook (lambda () (visual-line-mode)))
#+END_SRC
** default to not truncating lines in minibuffer
#+BEGIN_SRC emacs-lisp
(add-hook 'minibuffer-setup-hook
      (lambda () (setq truncate-lines nil)))
#+END_SRC
* text editing
** duplicate line or region
taken from tuxicity
https://rejeep.github.io/emacs/elisp/2010/03/11/duplicate-current-line-or-region-in-emacs.html
note that M-NumDuplicate or C-u NumDuplicate is the way to prefix multiple
#+BEGIN_SRC emacs-lisp
  (defun duplicate-current-line-or-region (arg)
    "Duplicates the current line or region ARG times. If there's no region, the current line will be duplicated. However, if there's a region, all lines that region covers will be duplicated."
    (interactive "p")
    (let (beg end (origin (point)))
      (if (and mark-active (> (point) (mark)))
          (exchange-point-and-mark))
      (setq beg (line-beginning-position))
      (if mark-active
          (exchange-point-and-mark))
      (setq end (line-end-position))
      (let ((region (buffer-substring-no-properties beg end)))
        (dotimes (i arg)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point)))
        (goto-char (+ origin (* (length region) arg) arg)))))
  (bind-key* "C-d" 'duplicate-current-line-or-region)
#+END_SRC
** indentation
*** spaces no tabs
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC
*** 4 spaces
#+BEGIN_SRC emacs-lisp
  (setq tab-width 4)
  (setq-default tab-width 4)
  (setq indent-line-function 'insert-tab)
  (setq-default c-basic-offset 4)
  (setq tab-stop-list '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80))
#+END_SRC
*** aggresive indent
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :diminish
    :hook (emacs-lisp-mode . aggressive-indent-mode))
#+END_SRC
** drag stuff
defined at startup because it's used in all modes
*** bindings to be overwritten by other modes
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-<up>")   #'drag-stuff-up)
  (global-set-key (kbd "M-<down>") #'drag-stuff-down)
  (global-set-key (kbd "M-<right>") #'drag-stuff-right)
  (global-set-key (kbd "M-<left>") #'drag-stuff-left)
#+END_SRC
*** bindings that won't be overwritten
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f6> x" 'drag-stuff-up) ; lpl+"n"
  (bind-key* "<f6> y" 'drag-stuff-down) ; lpl+"p"
#+END_SRC
** TODO delete line (all lines in region)
different than the built-in in that it deletes the newline before the killed line instead of after
- also I think you have to click built-in twice
#+BEGIN_SRC emacs-lisp
  (defun my-kill-whole-line ()
    (interactive)
    (setq line (line-number-at-pos))
    (if (< 1 line)
        (progn
          (previous-line)
          (move-end-of-line nil))
      (move-beginning-of-line nil))
    (kill-line)
    (unless (or (and (bobp) (not (eq ?\n (char-after))))(or (and (not (bobp))(eq ?\n (char-after))) (eobp)))
      (progn
        (append-next-kill)
        (kill-line)))
    )
  (defun my-kill-all-lines-in-region ()
    (interactive)
    (setq swap-p-m nil)
    (setq beg (line-beginning-position))
    (setq end (line-end-position))
    (setq num-lines 1)
    (if mark-active
        (progn
          (if (> (point) (mark))
              (progn
                (setq swap-p-m t)
                (exchange-point-and-mark)))
          (setq beg (line-beginning-position))
          (if mark-active
              (exchange-point-and-mark))
          (setq end (line-end-position))
          (unless swap-p-m
            (exchange-point-and-mark))))
    (unless (and (not mark-active)(and (bolp) (eq ?\n (char-after))))
      (setq num-lines (count-lines beg end)))
    (setq swap-p-m nil)
    (if mark-active
        (progn
          (if (< (point) (mark))
              (progn
                (setq swap-p-m t)
                (exchange-point-and-mark)))
          (if (and (bolp) (or (eobp) (eq ?\n (char-after))))
                                          ; count-lines doc explains why this is necessary
              (setq num-lines (1+ num-lines)))
          (message "%s" num-lines)
          (dotimes (i num-lines)
            (my-kill-whole-line))
          (unless swap-p-m
            (exchange-point-and-mark)))
      (my-kill-whole-line))
    )
  (bind-key* "<f5> j" 'my-kill-all-lines-in-region)
#+END_SRC
** commenting
found this on stack overflow
name based on functionality being like eclipse
#+BEGIN_SRC emacs-lisp
  (defun comment-eclipse ()
    (interactive)
    (let ((start (line-beginning-position))
          (end (line-end-position)))
      (when (or (not transient-mark-mode) (region-active-p))
        (setq start (save-excursion
                      (goto-char (region-beginning))
                      (beginning-of-line)
                      (point))
              end (save-excursion
                    (goto-char (region-end))
                    (end-of-line)
                    (point))))
      (comment-or-uncomment-region start end)))
  (bind-key* (kbd "M-;") 'comment-eclipse)
#+END_SRC
** multiple cursors
*** lists of commands to run once/for all
this needs to be run before requiring multiple cursors
#+BEGIN_SRC emacs-lisp
  (setq mc/list-file "~/.emacs.d/.mc-lists.el")
#+END_SRC
*** setup
#+BEGIN_SRC emacs-lisp
  (require 'multiple-cursors)
#+END_SRC
*** original hotkeys
;#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
#+END_SRC
*** hotkeys
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f6> k" 'mc/mark-next-like-this)
  (bind-key* "<f6> l" 'mc/mark-previous-like-this)
  (bind-key* "<f6> m" 'mc/mark-all-like-this)
  (bind-key* "<f6> n" 'mc/unmark-next-like-this)
  (bind-key* "<f6> o" 'mc/unmark-previous-like-this)
  (bind-key* "<mouse-8>" 'mc/add-cursor-on-click) ;; qmk btn4 reads as 8
  (bind-key* "<mouse-4>" 'mc/add-cursor-on-click) ;; qmk btn4 reads as 8
#+END_SRC
** TODO expand region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :defer 3
    :config
    (defun my-er/expand-region ()
      (interactive)
      (er/expand-region 1)))
  (bind-key* "C-c <C-f5> C-a" 'er/contract-region)
  (bind-key* "C-=" 'my-er/expand-region)
#+END_SRC

** electric pair mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode)
#+END_SRC
** shift by indentation
#+BEGIN_SRC emacs-lisp
  (defun my-indent-shift-left ()
    (setq swap-p-m nil)
    (interactive
     (progn
       (if mark-active
           (if (> (point) (mark))
               (progn
                 (exchange-point-and-mark)
                 (setq swap-p-m t))))
       (let ((deactivate-mark nil))
         (if mark-active
             (indent-rigidly (line-beginning-position) (region-end) (- 4))
           (indent-rigidly (line-beginning-position) (line-end-position) (- 4))))
       (if swap-p-m
           (exchange-point-and-mark)))
     )
    )

  (defun my-indent-shift-right ()
    (setq swap-p-m nil)
    (interactive
     (progn
       (if mark-active
           (if (> (point) (mark))
               (progn
                 (exchange-point-and-mark)
                 (setq swap-p-m t))))
       (let ((deactivate-mark nil))
         (if mark-active
             (indent-rigidly (line-beginning-position) (region-end) 4)
           (indent-rigidly (line-beginning-position) (line-end-position) 4)))
       (if swap-p-m
           (exchange-point-and-mark)))
     )
    )

  (bind-key* "<f5> n" 'my-indent-shift-right)
  (bind-key* "<f5> o" 'my-indent-shift-left)
#+END_SRC
*** TODO note that I fixed the exchange-point and mark issue
** TODO delete word forward
#+BEGIN_SRC emacs-lisp
#+END_SRC
* completion

** ivy
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :demand t
    :config
    (setq ivy-re-builders-alist
          '((t . ivy--regex-fuzzy)))
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-height 15)
    (ivy-mode))
  (bind-key* "<f6> z" 'swiper)
  (bind-key* "<f5> s" 'counsel-imenu)
  (bind-key* "M-x" 'counsel-M-x)
  (bind-key* "C-x C-f" 'counsel-find-file)
#+END_SRC
*** ivy rich
a lot of this is dealing with some performance issues associated with ivy rich
#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :after ivy
    :config
    (ivy-rich-mode 1)
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
    (ivy-rich-project-root-cache-mode)
    (eval-after-load 'ivy-rich
      (progn
        (defvar ek/ivy-rich-cache
          (make-hash-table :test 'equal))

        (defun ek/ivy-rich-cache-lookup (delegate candidate)
          (let ((result (gethash candidate ek/ivy-rich-cache)))
            (unless result
              (setq result (funcall delegate candidate))
              (puthash candidate result ek/ivy-rich-cache))
            result))

        (defun ek/ivy-rich-cache-reset ()
          (clrhash ek/ivy-rich-cache))

        (defun ek/ivy-rich-cache-rebuild ()
          (mapc (lambda (buffer)
                  (ivy-rich--ivy-switch-buffer-transformer (buffer-name buffer)))
                (buffer-list)))

        (defun ek/ivy-rich-cache-rebuild-trigger ()
          (ek/ivy-rich-cache-reset)
          (run-with-idle-timer 1 nil 'ek/ivy-rich-cache-rebuild))

        (advice-add 'ivy-rich--ivy-switch-buffer-transformer :around 'ek/ivy-rich-cache-lookup)
        (advice-add 'ivy-switch-buffer :after 'ek/ivy-rich-cache-rebuild-trigger)))

    )
#+END_SRC

** TODO helm
I think this needs to be above org
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :demand t)
  (use-package helm-flx
    :after helm
    :config
    (helm-flx-mode +1))
#+END_SRC
** flx
#+BEGIN_SRC emacs-lisp
(use-package flx)
#+END_SRC
* selection and clipboard
[[*navigation][navigation]] (for paragraphs
** delete highlighted text
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC
** shift selection
*** shift selection mode
#+BEGIN_SRC emacs-lisp
(setq shift-select-mode t)
#+END_SRC

*** mouse issue
without this it opens a menu when you S-mouse1
#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "<S-down-mouse-1>") 'mouse-save-then-kill)
#+END_SRC
** pasting from outside emacs
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC
* org
** Import
#+BEGIN_SRC emacs-lisp
  (require 'org)
#+END_SRC
** newlines for C-RET M-RET
#+BEGIN_SRC emacs-lisp
  (setq org-blank-before-new-entry (quote ((heading . nil)
                                           (plain-list-item . nil))))
#+END_SRC
** latex
#+BEGIN_SRC emacs-lisp
  ;; (use-package tex
  ;;   :demand t
  ;;   :config
  ;;   (setq TeX-auto-save t))
  ;; ;; (use-package auctex
  ;;   :demand t
  ;;   :no-require t
  ;;   :mode ("\\.tex\\'" . TeX-latex-mode)
  ;;   :config
  ;;   (defun latex-help-get-cmd-alist ()    ;corrected version:
  ;;     "Scoop up the commands in the index of the latex info manual.
  ;;   The values are saved in `latex-help-cmd-alist' for speed."
  ;;     ;; mm, does it contain any cached entries
  ;;     (if (not (assoc "\\begin" latex-help-cmd-alist))
  ;;         (save-window-excursion
  ;;           (setq latex-help-cmd-alist nil)
  ;;           (Info-goto-node (concat latex-help-file "Command Index"))
  ;;           (goto-char (point-max))
  ;;           (while (re-search-backward "^\\* \\(.+\\): *\\(.+\\)\\." nil t)
  ;;             (let ((key (buffer-substring (match-beginning 1) (match-end 1)))
  ;;                   (value (buffer-substring (match-beginning 2)
  ;;                                            (match-end 2))))
  ;;               (add-to-list 'latex-help-cmd-alist (cons key value))))))
  ;;     latex-help-cmd-alist)

  ;;   (add-hook 'TeX-after-compilation-finished-functions
  ;;             #'TeX-revert-document-buffer))
  ;; (setq-default TeX-engine 'xetex)
  ;; (setq org-latex-listings t)
  ;; (add-to-list 'org-latex-packages-alist '("" "listings"))
  ;; (add-to-list 'org-latex-packages-alist '("" "color"))
  ;; (setq org-latex-create-formula-image-program 'dvipng)
  ;; (org-babel-do-load-languages
  ;;  'org-babel-load-languages
  ;;  '((latex . t)))
#+END_SRC
*** format previews
#+BEGIN_SRC emacs-lisp
(setq org-format-latex-options
      (cdr '(_ :foreground "grey" ; default auto
               :background default
               :scale 3.0               ; 1.0
               :html-foreground "Black"
               :html-background "Transparent"
               :html-scale 1.0
               :matchers ("begin" "$1" "$" "$$" "\\(" "\\["))))
#+END_SRC
*** lualatex
;#+BEGIN_SRC emacs-lisp
;; lualatex preview
(setq org-latex-pdf-process
  '("lualatex -shell-escape -interaction nonstopmode %f"
    "lualatex -shell-escape -interaction nonstopmode %f"))

(setq luamagick '(luamagick :programs ("lualatex" "convert")
       :description "pdf > png"
       :message "you need to install lualatex and imagemagick."
       :use-xcolor t
       :image-input-type "pdf"
       :image-output-type "png"
       :image-size-adjust (1.0 . 1.0)
       :latex-compiler ("lualatex -interaction nonstopmode -output-directory %o %f")
       :image-converter ("convert -density %D -trim -antialias %f -quality 100 %O")))

(add-to-list 'org-preview-latex-process-alist luamagick)

(setq org-preview-latex-default-process 'luamagick)
#+END_SRC
** basic org configuration
*** allow me to set the display of inline images to certain size
#+BEGIN_SRC emacs-lisp
  (setq org-image-actual-width nil)
#+END_SRC
**** example syntax
#+ATTR_ORG: :width 100
*** folded
#+BEGIN_SRC emacs-lisp
  (setq org-startup-folded t)
#+END_SRC
*** indent-mode
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
#+END_SRC
*** no inline images at startup
#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images nil)
#+END_SRC
** pixel scrolling with inline images (various)
- there's an issue with this if you insert a new link while images are already displayed
- the toggle gets messed up
- going to scratch and executing the two setq lines should fix it
#+BEGIN_SRC emacs-lisp
  (defvar togglePixelScrollMode 1)
  (defun org-toggle-inline-images-and-pixel-scroll-mode ()
  (interactive)
  (if (eql togglePixelScrollMode 1)
    (pixel-scroll-mode 1))
  (if (eql togglePixelScrollMode 0)
    (pixel-scroll-mode -1))
  (setq togglePixelScrollMode (+ togglePixelScrollMode 1))
  (setq togglePixelScrollMode (mod togglePixelScrollMode 2))
  (org-toggle-inline-images))

  (define-key org-mode-map (kbd "C-c C-x C-v") #'org-toggle-inline-images-and-pixel-scroll-mode)
#+END_SRC

*** other things that worked half-way for this in the past
(setq jit-lock-defer-time 0)
(setq fast-but-imprecise-scrolling 't)
#+BEGIN_SRC emacs-lisp

  ;; (define-key org-mode-map (kbd "<C-c> <C-x> <C-v") 'org-toggle-inline-images-and-pixel-scroll-mode)

  ;; (global-set-key (kbd "C-c C-x C-v") 'org-toggle-inline-images-and-pixel-scroll-mode)

  ;; (bind-key* "<C-c> <C-x> <C-v>" 'org-toggle-inline-images-and-pixel-scroll-mode)

  ;; (with-eval-after-load 'org
  ;;        (bind-key "C-c x v" . 'org-toggle-inline-images-and-pixel-scroll-mode))

  ;; (add-hook 'org-mode-hook (local-set-key (kbd "C-c C-x C-v") (lambda ()
  ;;   (interactive)
  ;;   (org-toggle-inline-images)
  ;;   (pixel-scroll-mode)
  ;;   (message "Org Hook activated."))))

  ;; (global-set-key (kbd "C-c C-x C-v") (lambda () (interactive) (org-toggle-inline-images) (pixel-scroll-mode)))
#+END_SRC
** don't prompt for code evaluation (specified languages)
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC

;#+BEGIN_SRC emacs-lisp
(defun my-org-confirm-babel-evaluate (lang body)
  (not (string= lang "latex")))  
(setq org-confirm-babel-evaluate #'my-org-confirm-babel-evaluate)
#+END_SRC
** my org functions
*** navigate to end of subtree pre subheadings
#+BEGIN_SRC emacs-lisp
  (defun end-of-heading-pre-sub-headings ()
    (interactive)
    (end-of-line)
    (search-forward-regexp "^\\*+ \\|\\'")
    (beginning-of-line)
    (backward-char))
  (bind-key "<f6> p" 'end-of-heading-pre-sub-headings org-mode-map)
#+END_SRC
*** rename heading
#+BEGIN_SRC emacs-lisp
  (defun rename-heading ()
    (interactive)
    (search-forward-regexp "$")
    (search-backward-regexp "^\\*+ ")
    (forward-word)
    (backward-word)
    (setq beg (point))
    ;; (push-mark nil t t)
    (search-forward-regexp "$")
    (kill-region beg (point))
    ;; need these lines to deal with folded headings
    (search-backward-regexp "^\\*+ ")
    (search-forward-regexp "$")
    )
    (bind-key* "<f6> r" 'rename-heading)
#+END_SRC
*** new subheading respect content (or don't: C-u)
would need another function for todos
this needs to be below [[*navigate to end of subtree][navigate to end of subtree]]
#+BEGIN_SRC emacs-lisp
  (defun new-subheading-respect-content ()
    (interactive)
    (cond
     ((equal current-prefix-arg nil)
      (push-mark (point))
      (org-insert-heading-respect-content)
      (org-do-demote)
      (when (looking-at "\n\n") (delete-forward-char 1)))
     ((equal current-prefix-arg '(4))
      (end-of-heading-pre-sub-headings)
      (org-insert-heading)
      (org-do-demote)
      )
     )
    )
  (bind-key "C-M-<return>" 'new-subheading-respect-content org-mode-map)
#+END_SRC
** agenda stuff
*** custom command
#+BEGIN_SRC emacs-lisp
    (setq org-agenda-custom-commands
          '(("w" (
             (tags-todo "+test")))))
#+END_SRC
*** agenda directory (zettel)
#+BEGIN_SRC emacs-lisp
(setq org-agenda-files '("/home/nathanvercaemert/Zettelkasten/"))
#+END_SRC
** org-file-apps (backup webpages open with ubuntu firefox)
#+BEGIN_SRC emacs-lisp
  (setq org-file-apps
        '((auto-mode . emacs)
          ("\\.x?html?\\'" . "firefox %s")))
#+END_SRC
*** src this came from in case I want to expand
https://emacs.stackexchange.com/questions/29902/more-detailed-description-of-how-to-set-up-org-file-apps-for-orgmode-9-0

(defun whatacold/org-pdf-app (file-path link-without-schema)
  "Open pdf file using pdf-tools and go to the specified page."
  (let* ((page (if (not (string-match "\\.pdf::\\([0-9]+\\)\\'"
                                      link-without-schema))
                   1
                 (string-to-number (match-string 1 link-without-schema)))))
    (find-file-other-window file-path)
    (pdf-view-goto-page page)))

(setq org-file-apps
      '((auto-mode . emacs)
        ("\\.x?html?\\'" . "firefox %s")
        ("\\.pdf\\(::[0-9]+\\)?\\'" . whatacold/org-pdf-app)
        ("\\.gif\\'" . "eog \"%s\"")
        ("\\.mp4\\'" . "vlc \"%s\"")
        ("\\.mkv" . "vlc \"%s\"")))

** make sure regular links still go to chrome
#+BEGIN_SRC emacs-lisp
(when (and (eq system-type 'gnu/linux)
           (string-match
            "Linux.*Microsoft.*Linux"
            (shell-command-to-string "uname -a")))
  (setq
   browse-url-generic-program  "/mnt/c/Windows/System32/cmd.exe"
   browse-url-generic-args     '("/c" "start")
   browse-url-browser-function #'browse-url-generic))
#+END_SRC

** org-pdf-tools
#+BEGIN_SRC emacs-lisp
  (use-package org-pdftools
    :hook (org-mode . org-pdftools-setup-link))
#+END_SRC

** org links
*** no newline after inserting stored link
#+BEGIN_SRC emacs-lisp
  (defun my-insert-last-stored-link ()
    (interactive)
    (org-insert-last-stored-link 1)
    (when (looking-back "^") (delete-backward-char 1)))
#+END_SRC
*** toggle link display
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f6> h" 'org-toggle-link-display)
#+END_SRC
*** store link
#+BEGIN_SRC emacs-lisp
  ;; used to save the buffer in emacs, now I do it in qmk
  ;; (defun my-org-store-link ()
  ;;   (interactive)
  ;;   (org-store-link)
  ;;   (when ((string-equal (file-name-extension (buffer-file-name)) "pdf") 
  ;;         (save-buffer))))
  (bind-key* "<f6> i" 'org-store-link)
#+END_SRC
*** insert last stored link
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f6> j" 'my-insert-last-stored-link)
#+END_SRC
** helm-org
*** setup
#+BEGIN_SRC emacs-lisp
  (use-package helm-org
    :defer t
    :after helm)
#+END_SRC
*** set tags and capture
need helm mode for this
;#+BEGIN_SRC emacs-lisp
  (add-to-list 'helm-completing-read-handlers-alist '(org-capture . helm-org-completing-read-tags)) ;
  (add-to-list 'helm-completing-read-handlers-alist '(org-set-tags . helm-org-completing-read-tags))
#+END_SRC
** org-goto
note that C-u C-c C-j still allows access to classic interface
#+BEGIN_SRC emacs-lisp
  (setq org-goto-interface 'outline-path-completion)
  (setq org-outline-path-complete-in-steps nil)
  (bind-key* "<f6> q" 'org-goto)
#+END_SRC
*** worf
I used this before I realized org-goto can be configured the way I want.
;#+BEGIN_SRC emacs-lisp
  (use-package worf)
  (bind-key* "<f6> q" 'worf-goto)
#+END_SRC
** maybe insert images?
Maybe it will work on linux. Doesn't seem to want to work on Windows 10
Maybe Windows 11?
#+BEGIN_SRC emacs-lisp
(defun org-insert-image-from-clipboard ()
    "Take a screenshot into a time stamped unique-named file in the
same directory as the org-buffer and insert a link to this file. Depends in X.org to work (for now)"
    (interactive)
    (setq folder-name (concat (file-name-sans-extension (buffer-file-name)) "-orgimg"))
    (message folder-name)
    (if (not (file-directory-p folder-name))
        (make-directory folder-name nil))
    (setq filename
          (concat
           folder-name "/"
           (make-temp-name
            (concat ;(buffer-file-name) ;"-"
             (format-time-string "%Y%m%d_%H%M%S_")) ) ".png"))
    ;; TODO: add switch to detect Xorg or wayland session using (getenv "XDG_SESSION_TYPE")
    (insert
     (if (string= (car (split-string
                        (shell-command-to-string
                         (concat "xclip -selection clip -t image/png  -o >> " filename ))
                        ":")) "Error")
         (message "clipboard does not contain a image!")
       (concat "[[./" (file-relative-name filename) "]]")))
    (org-display-inline-images))
#+END_SRC
* yasnippet
** setup
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/elpa/yasnippet-0.14.0")
  (require 'yasnippet)
  (yas-global-mode 1)
#+END_SRC
** expand snippets custom binding
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f6> s" 'yas-expand)
  (bind-key* "ESC ESC <f5>" 'yas-expand)
#+END_SRC
** remove tab binding
#+BEGIN_SRC emacs-lisp 
  (define-key yas-minor-mode-map [(tab)] nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
#+END_SRC
* syntax
** sentences have one space after period
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

* navigation
** scrolling
*** vertical scroll step
#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
#+END_SRC
*** horizontal scrolling
#+BEGIN_SRC emacs-lisp
(defvar hStep 4)
(global-set-key (kbd "<mouse-7>") '(lambda ()
                                     (interactive)
                                     (scroll-left hStep)))
(global-set-key (kbd "<mouse-6>") '(lambda ()
                                     (interactive)
                                     (scroll-right hStep)))
#+END_SRC
*** disable notification about horizonal scrolling
#+BEGIN_SRC emacs-lisp
(put 'scroll-left 'disabled nil)
#+END_SRC
*** progressive scroll nil
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-progressive-speed nil)
#+END_SRC
*** pixel scrolling
#+BEGIN_SRC emacs-lisp
(setq pixel-dead-time 0)
(setq pixel-resolution-fine-flag t)
#+END_SRC
*** preserve screen position
#+BEGIN_SRC emacs-lisp
(setq scroll-preserve-screen-position 'always)
#+END_SRC
** better buffer selection
;#+BEGIN_SRC emacs-lisp
  (setq ibuffer-display-summary nil)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (defadvice ibuffer-update-title-and-summary (after remove-column-titles)
     (save-excursion
        (set-buffer "*Ibuffer*")
        (toggle-read-only 0)
        (goto-char 1)
        (search-forward "-\n" nil t)
        (delete-region 1 (point))
        (let ((window-min-height 1))
          ;; save a little screen estate
          (shrink-window-if-larger-than-buffer))
        (toggle-read-only)))
  (ad-activate 'ibuffer-update-title-and-summary)
#+END_SRC
** expected isearch functionality
have the next command execute at the beginning of the match
;#+BEGIN_SRC emacs-lisp
  (add-hook 'isearch-mode-end-hook
            #'endless/goto-match-beginning)
  (defun endless/goto-match-beginning ()
    "Go to the start of current isearch match.
  Use in `isearch-mode-end-hook'."
    (when (and isearch-forward
               (number-or-marker-p isearch-other-end)
               (not mark-active)
               (not isearch-mode-end-hook-quit))
      (goto-char isearch-other-end)))
#+END_SRC

#+RESULTS:
: endless/goto-match-beginning

** switch to/from minibuffer
#+BEGIN_SRC emacs-lisp
  (defun switch-to-minibuffer-window ()
    "switch to minibuffer window (if active)"
    (interactive)
    (when (active-minibuffer-window)
      (select-frame-set-input-focus (window-frame (active-minibuffer-window)))
      (select-window (active-minibuffer-window))))
  (bind-key* (kbd "C-M-<end>") 'switch-to-minibuffer-window)
  (bind-key* (kbd "C-M-<home>") 'other-window)
#+END_SRC
** other window
[[*switch to/from minibuffer][switch to/from minibuffer]]
** TODO paragraph motion and shift selection
#+BEGIN_SRC emacs-lisp
  (defun backward-paragraph-with-shift-select ()
    (interactive)
    (setq this-command-keys-shift-translated t)
    (call-interactively 'backward-paragraph))

  (defun forward-paragraph-with-shift-select ()
    (interactive)
    (setq this-command-keys-shift-translated t)
    (call-interactively 'forward-paragraph))

  (bind-key* "<f5> 3" 'forward-paragraph)
  (bind-key* "S-<f5> #" 'forward-paragraph-with-shift-select)
  (bind-key* "<f5> 2" 'backward-paragraph)
  (bind-key* "S-<f5> @" 'backward-paragraph-with-shift-select)
#+END_SRC

*** paragraph C-M-a C-M-e
;#+BEGIN_SRC emacs-lisp
(bind-key* "C-M-b" 'backward-paragraph)
(bind-key* "C-M-f" 'forward-paragraph)
#+END_SRC

** sentences
this should be default...
;#+BEGIN_SRC emacs-lisp
(bind-key* "M-a" 'backward-sentence)
(bind-key* "M-e" 'forward-sentence)
#+END_SRC

** disable basic arrow movement
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "<left>"))
(global-unset-key (kbd "<right>"))
(global-unset-key (kbd "<up>"))
(global-unset-key (kbd "<down>"))
#+END_SRC
** mouse focus issues
#+BEGIN_SRC emacs-lisp
(setq focus-follows-mouse t)
(setq mouse-autoselect-window t)
#+END_SRC
** TODO avy
#+BEGIN_SRC emacs-lisp
    (setq search-invisible nil)
    ;; ; just org mode
    ;; (add-hook 'org-mode-hook
    ;;           (lambda ()
    ;;             (make-local-variable 'search-invisible)
    ;;             (setq search-invisible nil)))

    (autoload 'View-scroll-half-page-forward "view")
    (autoload 'View-scroll-half-page-backward "view")
    (global-set-key (kbd "C-v") 'View-scroll-half-page-forward)
    (global-set-key (kbd "M-v") 'View-scroll-half-page-backward)

    (setq org-tags-column 0)

    (use-package avy
      :config
      (setq avy-timeout-seconds 100
            )
      ;; (avy-all-windows t)
      :custom-face
      (avy-goto-char-timer-face ((t (:foreground "000000" :background "#FFFFFF" :weight bold :underline "red"))))
      ;; :config
      ;;  ;; this makes matches closer to point have shorter avy-sequences
      ;; (setq avy-orders-alist
      ;;       '((avy-goto-char . avy-order-closest)
      ;;         (avy-goto-word-0 . avy-order-closest)))
      )
    (bind-key* "<f5> 1" 'avy-goto-char-timer)
#+END_SRC

** mark ring 
*** is mark at point
#+BEGIN_SRC emacs-lisp
(defun marker-is-point-p (marker)
  "test if marker is current point"
  (and (eq (marker-buffer marker) (current-buffer))
       (= (marker-position marker) (point))))
#+END_SRC
*** local push mark maybe
#+BEGIN_SRC emacs-lisp
  (defun push-local-mark-maybe () 
    "push mark onto `local-mark-ring' if mark head or tail is not current location"
    (if (not mark-ring) (error "local-mark-ring empty")
      (unless (or (marker-is-point-p (car mark-ring))
                  (marker-is-point-p (car (reverse mark-ring))))
        (push-mark)
        (pop-to-mark-command))))
#+END_SRC
*** local back mark
#+BEGIN_SRC emacs-lisp
    (defun backward-local-mark()
      "pop local mark, pushing current point if not on ring"
      (interactive)
      (push-local-mark-maybe)
      (pop-to-mark-command))
(bind-key* "<f6> v" 'backward-local-mark)
#+END_SRC

*** local forward mark
#+BEGIN_SRC emacs-lisp
(defun unpop-to-mark-command ()
  "Unpop off mark ring. Does nothing if mark ring is empty."
  (interactive)
  (push-local-mark-maybe)
      (when mark-ring
        (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
        (set-marker (mark-marker) (car (last mark-ring)) (current-buffer))
        (when (null (mark t)) (ding))
        (setq mark-ring (nbutlast mark-ring))
        (goto-char (marker-position (car (last mark-ring))))))
(bind-key* "<f5> z" 'unpop-to-mark-command)
#+END_SRC
*** global push mark maybe
#+BEGIN_SRC emacs-lisp
  (defun push-global-mark-maybe () 
    "push mark onto `global-mark-ring' if mark head or tail is not current location"
    (if (not global-mark-ring) (error "global-mark-ring empty")
      (unless (or (marker-is-point-p (car global-mark-ring))
                  (marker-is-point-p (car (reverse global-mark-ring))))
        (push-mark))))
#+END_SRC
*** global back mark
#+BEGIN_SRC emacs-lisp
(defun backward-global-mark () 
  "use `pop-global-mark', pushing current point if not on ring."
  (interactive)
  (push-global-mark-maybe)
  (when (marker-is-point-p (car global-mark-ring))
    (call-interactively 'pop-global-mark))
  (call-interactively 'pop-global-mark))
(bind-key* "<f6> u" 'backward-global-mark)
#+END_SRC
*** global forward mark
#+BEGIN_SRC emacs-lisp
(defun forward-global-mark ()
  "hack `pop-global-mark' to go in reverse, pushing current point if not on ring."
  (interactive)
  (push-global-mark-maybe)
  (setq global-mark-ring (nreverse global-mark-ring))
  (when (marker-is-point-p (car global-mark-ring))
    (call-interactively 'pop-global-mark))
  (call-interactively 'pop-global-mark)
  (setq global-mark-ring (nreverse global-mark-ring)))
(bind-key* "<f6> f" 'forward-global-mark)
#+END_SRC
* window/buffer functions
** split window
#+BEGIN_SRC emacs-lisp
  (defun my-split-window-vertical ()
    (interactive)
    (split-window-below)
    (other-window 1)
    (balance-windows))
  (defun my-split-window-horizontal ()
    (interactive)
    (split-window-right)
    (other-window 1)
    (balance-windows))
    (bind-key* "<f5> a" 'my-split-window-vertical)
    (bind-key* "<f5> b" 'my-split-window-horizontal)
#+END_SRC
** kill window
#+BEGIN_SRC emacs-lisp
  (defun my-kill-window ()
    (interactive)
    (delete-window)
    (balance-windows))
    (bind-key* "<f5> c" 'my-kill-window)

#+END_SRC
** kill this buffer
#+BEGIN_SRC emacs-lisp
  (setq not-to-kill-buffer-list '("*scratch*" "*Messages*"))
  (defun kill-buffer-but-not-some ()
    (interactive)
    (if (member (buffer-name (current-buffer)) not-to-kill-buffer-list)
        (bury-buffer)
      (kill-buffer (current-buffer))))
  (bind-key* "<f5> f" 'kill-buffer-but-not-some)
#+END_SRC
** windmove
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f5> k" 'windmove-right)
  (bind-key* "<f5> h" 'windmove-up)
  (bind-key* "<f5> i" 'windmove-left)
  (bind-key* "<f5> l" 'windmove-down)
#+END_SRC
** my delete other windows
I think this forces the "only window" functionality. I've had some issues with the window I want to become the only window not Beckman the only window.
#+BEGIN_SRC emacs-lisp
  (defun my-delete-other-windows ()
    (interactive)
    (setq temp ignore-window-parameters)
    (setq ignore-window-parameters t)
    (delete-other-windows)
    (setq ignore-window-parameters temp)
    )
  (bind-key* "<f5> m" 'my-delete-other-windows)
#+END_SRC
* bookmarks
** only list the names of bookmarks
#+BEGIN_SRC emacs-lisp
  (setq bookmark-bmenu-toggle-filenames nil)
#+END_SRC

** startup to bookmarks
#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
  (require 'bookmark)
  (list-bookmarks)
  (switch-to-buffer "*Bookmark List*")
#+END_SRC

** save bookmarks with every bookmark action
#+BEGIN_SRC emacs-lisp
(setq bookmark-save-flag 1)
#+END_SRC
* (auto revert) reload files when changed externally
** set auto-revert so that it's time based instead of system notification
#+BEGIN_SRC emacs-lisp
(setq auto-revert-verbose nil)
(setq auto-revert-interval 1)
#+END_SRC

** turn auto-revert-mode on everywhere
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode)
  ;; (defun revert-buffer-no-confirm ()
  ;;     "Revert buffer without confirmation."
  ;;     (interactive)
  ;;     (revert-buffer :ignore-auto :noconfirm))
#+END_SRC
** crazy long shot code that might do what I want
#+BEGIN_SRC emacs-lisp
;;
;; Fix the auto-revert-handler so that if the system time is the
;; same as the new modified time for a file, skip it on this
;; iteration. This should fix race conditions when a file is changed
;; multiple times within the same second.
;;

(defun file-change-too-close-for-comfort ()
  (let* ((file-time-raw (nth 5 (file-attributes (buffer-file-name))))
         (file-time (+ (lsh (nth 0 file-time-raw) 16) (nth 1 file-time-raw)))
         (current-time (+ (lsh (nth 0 (current-time)) 16) (nth 1 (current-time)))))
    (and (eq current-time file-time)
         (message "%s: postpone revert" (buffer-name))
         t)))


(defun auto-revert-handler ()
  "Revert current buffer, if appropriate.
This is an internal function used by Auto-Revert Mode."
  (when (or auto-revert-tail-mode (not (buffer-modified-p)))
    (let* ((buffer (current-buffer)) size
           (revert
            (or (and buffer-file-name
                     (file-readable-p buffer-file-name)
                     (if auto-revert-tail-mode
                         ;; Tramp caches the file attributes.  Setting
                         ;; `tramp-cache-inhibit' forces Tramp to
                         ;; reread the values.
                         (let ((tramp-cache-inhibit-cache t))
                           (/= auto-revert-tail-pos
                               (setq size
                                     (nth 7 (file-attributes
                                             buffer-file-name)))))
                       (and (not (file-remote-p buffer-file-name))
                            (not (verify-visited-file-modtime buffer))
                            (not (file-change-too-close-for-comfort)))))
                (and (or auto-revert-mode
                         global-auto-revert-non-file-buffers)
                     revert-buffer-function
                     (boundp 'buffer-stale-function)
                     (functionp buffer-stale-function)
                     (funcall buffer-stale-function t))))
           eob eoblist)
      (when revert
        (when (and auto-revert-verbose
                   (not (eq revert 'fast)))
          (message "Reverting buffer `%s'." (buffer-name)))
        ;; If point (or a window point) is at the end of the buffer,
        ;; we want to keep it at the end after reverting.  This allows
        ;; to tail a file.
        (when buffer-file-name
          (setq eob (eobp))
          (walk-windows
           #'(lambda (window)
               (and (eq (window-buffer window) buffer)
                    (= (window-point window) (point-max))
                    (push window eoblist)))
           'no-mini t))
        (if auto-revert-tail-mode
            (auto-revert-tail-handler size)
          ;; Bind buffer-read-only in case user has done C-x C-q,
          ;; so as not to forget that.  This gives undesirable results
          ;; when the file's mode changes, but that is less common.
          (let ((buffer-read-only buffer-read-only))
            (revert-buffer 'ignore-auto 'dont-ask 'preserve-modes)))
        (when buffer-file-name
          (when eob (goto-char (point-max)))
          (dolist (window eoblist)
            (set-window-point window (point-max)))))
      ;; `preserve-modes' avoids changing the (minor) modes.  But we
      ;; do want to reset the mode for VC, so we do it manually.
      (when (or revert auto-revert-check-vc-info)
        (vc-find-file-hook)))))
#+END_SRC
* dired
[[*highlight current line (hl-line-mode)][highlight current line (hl-line-mode)]]
** colors
*** diredfl
#+BEGIN_SRC emacs-lisp
  (use-package diredfl
    :config
    (diredfl-global-mode))
    ;; :hook
    ;; (dired-mode . diredfl-mode))
#+END_SRC
*** dired rainbow
#+BEGIN_SRC emacs-lisp
  (use-package dired-rainbow
    :after diredfl
    :config
    (progn
      (dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
      (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
      (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
      (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
      (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
      (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
      (dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
      (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
      (dired-rainbow-define log "#c17d11" ("log"))
      (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
      (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
      (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
      (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
      (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
      (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
      (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
      (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
      (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
      (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
      (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*"))) 
#+END_SRC
** do what I mean target
#+BEGIN_SRC emacs-lisp
(setq dired-dwim-target t)
#+END_SRC
** change listing order/contents
#+BEGIN_SRC emacs-lisp
  ;; (setq dired-listing-switches "-alDphgG")
  (setq dired-listing-switches "-alDphgG")
#+END_SRC
** dired-details
#+BEGIN_SRC emacs-lisp
  (add-hook 'dired-mode-hook
            (lambda ()
              (dired-hide-details-mode)))
  (use-package emacs
    :config
    ;; overwrite so that it only hides the information line
    ;; this function is originally from dired.el
    (defun dired-hide-details-update-invisibility-spec ()
      (funcall (if (and dired-hide-details-mode
                        dired-hide-details-hide-information-lines)
                   'add-to-invisibility-spec
                 'remove-from-invisibility-spec)
               'dired-hide-details-information))
    )
#+END_SRC
** make file sizes make sense
#+BEGIN_SRC emacs-lisp
(setq dired-free-space-args "-Pm")
#+END_SRC
** make copies recursive always
#+BEGIN_SRC emacs-lisp
(setq dired-recursive-copies 'always)
#+END_SRC
** dired bindings
#+BEGIN_SRC emacs-lisp
  (bind-key "C-c C-n" 'dired-next-subdir dired-mode-map)
  (bind-key "C-c C-p" 'dired-prev-subdir dired-mode-map)
  (bind-key "C-c C-u" 'dired-tree-up dired-mode-map)
  ;; (bind-key "C-c @" 'dired-hide-subdir dired-mode-map)
  (bind-key "<f6> p" 'dired-maybe-insert-subdir dired-mode-map)
  (bind-key "<f5> r" 'dired-kill-subdir dired-mode-map)
#+END_SRC
** open directory in explorer
#+BEGIN_SRC emacs-lisp
  (defun browse-file-directory ()
    "Open the current file's directory however the OS would."
    (interactive)
    (setq directoryName (expand-file-name default-directory))
    ;; (message "%s" directoryName))
    (if default-directory
        (browse-url-of-file (concat "\\\\wsl$\\Ubuntu\\" directoryName))
      (error "No `default-directory' to open")))
  (bind-key* "<f5> p" 'browse-file-directory)
#+END_SRC
** dired filter
this hides dot files (and hides the message saying they're being hidden)
#+BEGIN_SRC emacs-lisp
  (use-package dired-filter
    :custom
    (dired-filter-show-filters nil)
    :hook
    (dired-mode . dired-filter-by-dot-files))
#+END_SRC
** old dired
*** enable dired jump
;#+BEGIN_SRC emacs-lisp
(require 'dired-x)
#+END_SRC
*** automatically revert non-file buffers
this is under dired because that's where I notice it lacking
I don't think this was working, so moved to old
;#+BEGIN_SRC emacs-lisp
  (setq global-auto-revert-non-file-buffers t)
; (setq auto-revert-verbose nil)  ; this would silence the notification
#+END_SRC
*** revert after hiding
not sure what this does
;#+BEGIN_SRC emacs-lisp
  (defun my-dired-hide-subdir ()
    "takes care of reverting for dired-details"
    (interactive)
    (dired-hide-subdir 1)
    (revert-buffer))
  (defun my-dired-hide-all ()
    "takes care of reverting for dired-details"
    (interactive)
    (dired-hide-all 1)
    (revert-buffer))
#+END_SRC

*** diredful
;#+BEGIN_SRC emacs-lisp
  (use-package diredful
    :after diredfl
    :config
    (diredful-mode 1)
    )

#+END_SRC
*** dired-subtree
;#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :custom
    (dired-subtree-use-backgrounds . nil)
    :config
    (bind-key "<tab>" 'dired-subtree-toggle dired-mode-map)
    (bind-key "<f5> q" 'dired-subtree-up dired-mode-map)
    )
#+END_SRC
* phi-search
#+BEGIN_SRC emacs-lisp
  (require 'phi-search)
  ;; can't get this to work for some reason, I guess I just have to complete search and move from there
  ;; (bind-key "<C-return>" 'phi-search-complete phi-search-default-map)
  (bind-key "<return>" 'phi-search-complete-at-beginning phi-search-default-map)
  #+END_SRC
* interaction log
#+BEGIN_SRC emacs-lisp
  (require 'interaction-log)
  (interaction-log-mode +1)
  (global-set-key
   (kbd "C-h C-l")
   (lambda () (interactive) (display-buffer ilog-buffer-name)))
#+END_SRC
* flyspell
** basic emacswiki setup
#+BEGIN_SRC emacs-lisp
  (defun flyspell-on-for-buffer-type ()
    "Enable Flyspell appropriately for the major mode of the current buffer.  Uses `flyspell-prog-mode' for modes derived from `prog-mode', so only strings and comments get checked.  All other buffers get `flyspell-mode' to check all text.  If flyspell is already enabled, does nothing."
    (interactive)
    (if (not (eq major-mode 'vterm-mode)) ; flyspell causes problems in vterm
        (if (not (symbol-value flyspell-mode)) ; if not already on
            (progn
              (if (derived-mode-p 'prog-mode)
                  (progn
                    (message "Flyspell on (code)")
                    (flyspell-prog-mode))
                ;; else
                (progn
                  (message "Flyspell on (text)")
                  (flyspell-mode 1)))
              ;; I tried putting (flyspell-buffer) here but it didn't seem to work
              ))))

  (defun flyspell-toggle ()
    "Turn Flyspell on if it is off, or off if it is on.  When turning on, it uses `flyspell-on-for-buffer-type' so code-vs-text is handled appropriately."
    (interactive)
    (if (symbol-value flyspell-mode)
        (progn ; flyspell is on, turn it off
          (message "Flyspell off")
          (flyspell-mode -1))
                                          ; else - flyspell is off, turn it on
      (flyspell-on-for-buffer-type)))

  (add-hook 'find-file-hook 'flyspell-on-for-buffer-type)

  (add-hook 'after-change-major-mode-hook 'flyspell-on-for-buffer-type)

  ;; (add-hook 'vterm-mode-hook (flyspell-mode -1))
#+END_SRC
* desktop save mode
#+BEGIN_SRC emacs-lisp
  (setq desktop-path (list "~/"))
  (desktop-save-mode 1)
  (setq desktop-auto-save-timeout nil)
#+END_SRC
* helm/ivy-bibtex
#+BEGIN_SRC emacs-lisp
  (setq bibtex-completion-bibliography '("~/My Library.bib"))
  (setq bibtex-completion-pdf-field "File")
#+END_SRC
* undo, redo, and undo-tree
q 'undo-tree-visualizer-quit
C-q 'undo-tree-visualizer-abort
#+BEGIN_SRC emacs-lisp
  (bind-key* "<f8>"  'undo)
  (use-package undo-tree
    :diminish
    :config
    (global-undo-tree-mode +1)
    (bind-key* "M-<f8>" 'undo-tree-visualize)
    (bind-key* "C-<f8>"  'undo-tree-redo))
#+END_SRC
* TODO new stuff
** visible mark
my repo coming from:  https://git.sr.ht/~iank/visible-mark
which is the new location originally moved from: https://gitlab.com/iankelling/visible-mark
#+BEGIN_SRC emacs-lisp
  (straight-use-package '(visible-mark :type git :host github :repo "nathanvercaemert/visible-mark"))
  (defface visible-mark-active
    '((((type tty) (class mono)))
      (t (:background "magenta"))) "")
  (setq visible-mark-max 2)
  (setq visible-mark-faces `(visible-mark-face1 visible-mark-face2))
  (require 'visible-mark)
  (global-visible-mark-mode 1)
#+END_SRC
